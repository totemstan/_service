'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Matrix = require('ml-matrix');
var Matrix__default = _interopDefault(Matrix);
var Stat = _interopDefault(require('ml-stat/matrix'));

/**
 * @private
 * Function that given vector, returns his norm
 * @param {Vector} X
 * @return {number} Norm of the vector
 */
function norm(X) {
    return Math.sqrt(X.clone().apply(pow2array).sum());
}

/**
 * @private
 * Function that pow 2 each element of a Matrix or a Vector,
 * used in the apply method of the Matrix object
 * @param {number} i - index i.
 * @param {number} j - index j.
 * @return {Matrix} The Matrix object modified at the index i, j.
 * */
function pow2array(i, j) {
    this[i][j] = this[i][j] * this[i][j];
    return this;
}

/**
 * @private
 * Function that normalize the dataset and return the means and
 * standard deviation of each feature.
 * @param {Matrix} dataset
 * @return {object} dataset normalized, means and standard deviations
 */


/**
 * @private
 * Function that initialize an array of matrices.
 * @param {Array} array
 * @param {boolean} isMatrix
 * @return {Array} array with the matrices initialized.
 */
function initializeMatrices(array, isMatrix) {
    if (isMatrix) {
        for (var i = 0; i < array.length; ++i) {
            for (var j = 0; j < array[i].length; ++j) {
                var elem = array[i][j];
                array[i][j] = elem !== null ? new Matrix__default(array[i][j]) : undefined;
            }
        }
    } else {
        for (i = 0; i < array.length; ++i) {
            array[i] = new Matrix__default(array[i]);
        }
    }

    return array;
}

/**
 * @class PLS
 */
class PLS {

    /**
     * Constructor for Partial Least Squares (PLS)
     * @param {object} options
     * @param {number} [options.latentVectors] - Number of latent vector to get (if the algorithm doesn't find a good model below the tolerance)
     * @param {number} [options.tolerance=1e-5]
     * @param {boolean} [options.scale=true] - rescale dataset using mean.
     * @param {object} model - for load purposes.
     */
    constructor(options, model) {
        if (options === true) {
            this.meanX = model.meanX;
            this.stdDevX = model.stdDevX;
            this.meanY = model.meanY;
            this.stdDevY = model.stdDevY;
            this.PBQ = Matrix__default.checkMatrix(model.PBQ);
            this.R2X = model.R2X;
            this.scale = model.scale;
            this.scaleMethod = model.scaleMethod;
            this.tolerance = model.tolerance;
        } else {
            var {
                tolerance = 1e-5,
                scale = true,
            } = options;
            this.tolerance = tolerance;
            this.scale = scale;
            this.latentVectors = options.latentVectors;
        }
    }

    /**
     * Fits the model with the given data and predictions, in this function is calculated the
     * following outputs:
     *
     * T - Score matrix of X
     * P - Loading matrix of X
     * U - Score matrix of Y
     * Q - Loading matrix of Y
     * B - Matrix of regression coefficient
     * W - Weight matrix of X
     *
     * @param {Matrix|Array} trainingSet
     * @param {Matrix|Array} trainingValues
     */
    train(trainingSet, trainingValues) {
        trainingSet = Matrix__default.checkMatrix(trainingSet);
        trainingValues = Matrix__default.checkMatrix(trainingValues);

        if (trainingSet.length !== trainingValues.length) {
            throw new RangeError('The number of X rows must be equal to the number of Y rows');
        }

        this.meanX = Stat.mean(trainingSet);
        this.stdDevX = Stat.standardDeviation(trainingSet, this.meanX, true);
        this.meanY = Stat.mean(trainingValues);
        this.stdDevY = Stat.standardDeviation(trainingValues, this.meanY, true);

        if (this.scale) { // here should be the ml-preprocess project
            trainingSet = trainingSet.clone().subRowVector(this.meanX).divRowVector(this.stdDevX);
            trainingValues = trainingValues.clone().subRowVector(this.meanY).divRowVector(this.stdDevY);
        }

        if (this.latentVectors === undefined) {
            this.latentVectors = Math.min(trainingSet.length - 1, trainingSet[0].length);
        }

        var rx = trainingSet.rows;
        var cx = trainingSet.columns;
        var ry = trainingValues.rows;
        var cy = trainingValues.columns;

        var ssqXcal = trainingSet.clone().mul(trainingSet).sum(); // for the rÂ²
        var sumOfSquaresY = trainingValues.clone().mul(trainingValues).sum();

        var tolerance = this.tolerance;
        var n = this.latentVectors;
        var T = Matrix__default.zeros(rx, n);
        var P = Matrix__default.zeros(cx, n);
        var U = Matrix__default.zeros(ry, n);
        var Q = Matrix__default.zeros(cy, n);
        var B = Matrix__default.zeros(n, n);
        var W = P.clone();
        var k = 0;

        while (norm(trainingValues) > tolerance && k < n) {
            var transposeX = trainingSet.transpose();
            var transposeY = trainingValues.transpose();

            var tIndex = maxSumColIndex(trainingSet.clone().mulM(trainingSet));
            var uIndex = maxSumColIndex(trainingValues.clone().mulM(trainingValues));

            var t1 = trainingSet.getColumnVector(tIndex);
            var u = trainingValues.getColumnVector(uIndex);
            var t = Matrix__default.zeros(rx, 1);

            while (norm(t1.clone().sub(t)) > tolerance) {
                var w = transposeX.mmul(u);
                w.div(norm(w));
                t = t1;
                t1 = trainingSet.mmul(w);
                var q = transposeY.mmul(t1);
                q.div(norm(q));
                u = trainingValues.mmul(q);
            }

            t = t1;
            var num = transposeX.mmul(t);
            var den = (t.transpose().mmul(t))[0][0];
            var p = num.div(den);
            var pnorm = norm(p);
            p.div(pnorm);
            t.mul(pnorm);
            w.mul(pnorm);

            num = u.transpose().mmul(t);
            den = (t.transpose().mmul(t))[0][0];
            var b = (num.div(den))[0][0];
            trainingSet.sub(t.mmul(p.transpose()));
            trainingValues.sub(t.clone().mul(b).mmul(q.transpose()));

            T.setColumn(k, t);
            P.setColumn(k, p);
            U.setColumn(k, u);
            Q.setColumn(k, q);
            W.setColumn(k, w);

            B[k][k] = b;
            k++;
        }

        k--;
        T = T.subMatrix(0, T.rows - 1, 0, k);
        P = P.subMatrix(0, P.rows - 1, 0, k);
        U = U.subMatrix(0, U.rows - 1, 0, k);
        Q = Q.subMatrix(0, Q.rows - 1, 0, k);
        W = W.subMatrix(0, W.rows - 1, 0, k);
        B = B.subMatrix(0, k, 0, k);

        // TODO: review of R2Y
        //this.R2Y = t.transpose().mmul(t).mul(q[k][0]*q[k][0]).divS(ssqYcal)[0][0];
        //
        this.ssqYcal = sumOfSquaresY;
        this.E = trainingSet;
        this.F = trainingValues;
        this.T = T;
        this.P = P;
        this.U = U;
        this.Q = Q;
        this.W = W;
        this.B = B;
        this.PBQ = P.mmul(B).mmul(Q.transpose());
        this.R2X = t.transpose().mmul(t).mmul(p.transpose().mmul(p)).div(ssqXcal)[0][0];
    }

    /**
     * Predicts the behavior of the given dataset.
     * @param {Matrix|Array} dataset - data to be predicted.
     * @return {Matrix} - predictions of each element of the dataset.
     */
    predict(dataset) {
        var X = Matrix__default.checkMatrix(dataset);
        if (this.scale) {
            X = X.subRowVector(this.meanX).divRowVector(this.stdDevX);
        }
        var Y = X.mmul(this.PBQ);
        Y = Y.mulRowVector(this.stdDevY).addRowVector(this.meanY);
        return Y;
    }

    /**
     * Returns the explained variance on training of the PLS model
     * @return {number}
     */
    getExplainedVariance() {
        return this.R2X;
    }

    /**
     * Export the current model to JSON.
     * @return {object} - Current model.
     */
    toJSON() {
        return {
            name: 'PLS',
            R2X: this.R2X,
            meanX: this.meanX,
            stdDevX: this.stdDevX,
            meanY: this.meanY,
            stdDevY: this.stdDevY,
            PBQ: this.PBQ,
            tolerance: this.tolerance,
            scale: this.scale,
        };
    }

    /**
     * Load a PLS model from a JSON Object
     * @param {object} model
     * @return {PLS} - PLS object from the given model
     */
    static load(model) {
        if (model.name !== 'PLS') {
            throw new RangeError('Invalid model: ' + model.name);
        }
        return new PLS(true, model);
    }
}

/**
 * @private
 * Function that returns the index where the sum of each
 * column vector is maximum.
 * @param {Matrix} data
 * @return {number} index of the maximum
 */
function maxSumColIndex(data) {
    return data.sum('column').maxIndex()[0];
}

/**
 * @class KOPLS
 */
class KOPLS {

    /**
     * Constructor for Kernel-based Orthogonal Projections to Latent Structures (K-OPLS)
     * @param {object} options
     * @param {number} [options.predictiveComponents] - Number of predictive components to use.
     * @param {number} [options.orthogonalComponents] - Number of Y-Orthogonal components.
     * @param {Kernel} [options.kernel] - Kernel object to apply, see [ml-kernel](https://github.com/mljs/kernel).
     * @param {object} model - for load purposes.
     */
    constructor(options, model) {
        if (options === true) {
            this.trainingSet = new Matrix.Matrix(model.trainingSet);
            this.YLoadingMat = new Matrix.Matrix(model.YLoadingMat);
            this.SigmaPow = new Matrix.Matrix(model.SigmaPow);
            this.YScoreMat = new Matrix.Matrix(model.YScoreMat);
            this.predScoreMat = initializeMatrices(model.predScoreMat, false);
            this.YOrthLoadingVec = initializeMatrices(model.YOrthLoadingVec, false);
            this.YOrthEigen = model.YOrthEigen;
            this.YOrthScoreMat = initializeMatrices(model.YOrthScoreMat, false);
            this.toNorm = initializeMatrices(model.toNorm, false);
            this.TURegressionCoeff = initializeMatrices(model.TURegressionCoeff, false);
            this.kernelX = initializeMatrices(model.kernelX, true);
            this.kernel = model.kernel;
            this.orthogonalComp = model.orthogonalComp;
            this.predictiveComp = model.predictiveComp;
        } else {
            if (options.predictiveComponents === undefined) {
                throw new RangeError('no predictive components found!');
            }
            if (options.orthogonalComponents === undefined) {
                throw new RangeError('no orthogonal components found!');
            }
            if (options.kernel === undefined) {
                throw new RangeError('no kernel found!');
            }

            this.orthogonalComp = options.orthogonalComponents;
            this.predictiveComp = options.predictiveComponents;
            this.kernel = options.kernel;
        }
    }

    /**
     * Train the K-OPLS model with the given training set and labels.
     * @param {Matrix|Array} trainingSet
     * @param {Matrix|Array} trainingValues
     */
    train(trainingSet, trainingValues) {
        trainingSet = Matrix.Matrix.checkMatrix(trainingSet);
        trainingValues = Matrix.Matrix.checkMatrix(trainingValues);

        // to save and compute kernel with the prediction dataset.
        this.trainingSet = trainingSet.clone();

        var kernelX = this.kernel.compute(trainingSet);

        var Identity = Matrix.Matrix.eye(kernelX.rows, kernelX.rows, 1);
        var temp = kernelX;
        kernelX = new Matrix.Matrix(this.orthogonalComp + 1, this.orthogonalComp + 1);
        kernelX[0][0] = temp;

        var result = new Matrix.SingularValueDecomposition(trainingValues.transpose().mmul(kernelX[0][0]).mmul(trainingValues), {
            computeLeftSingularVectors: true,
            computeRightSingularVectors: false
        });
        var YLoadingMat = result.leftSingularVectors;
        var Sigma = result.diagonalMatrix;

        YLoadingMat = YLoadingMat.subMatrix(0, YLoadingMat.rows - 1, 0, this.predictiveComp - 1);
        Sigma = Sigma.subMatrix(0, this.predictiveComp - 1, 0, this.predictiveComp - 1);

        var YScoreMat = trainingValues.mmul(YLoadingMat);

        var predScoreMat = new Array(this.orthogonalComp + 1);
        var TURegressionCoeff = new Array(this.orthogonalComp + 1);
        var YOrthScoreMat = new Array(this.orthogonalComp);
        var YOrthLoadingVec = new Array(this.orthogonalComp);
        var YOrthEigen = new Array(this.orthogonalComp);
        var YOrthScoreNorm = new Array(this.orthogonalComp);

        var SigmaPow = Matrix.Matrix.pow(Sigma, -0.5);
        // to avoid errors, check infinity
        SigmaPow.apply(function (i, j) {
            if (this[i][j] === Infinity) {
                this[i][j] = 0.0;
            }
        });

        for (var i = 0; i < this.orthogonalComp; ++i) {
            predScoreMat[i] = kernelX[0][i].transpose().mmul(YScoreMat).mmul(SigmaPow);

            var TpiPrime = predScoreMat[i].transpose();
            TURegressionCoeff[i] = Matrix.inverse(TpiPrime.mmul(predScoreMat[i])).mmul(TpiPrime).mmul(YScoreMat);

            result = new Matrix.SingularValueDecomposition(TpiPrime.mmul(Matrix.Matrix.sub(kernelX[i][i], predScoreMat[i].mmul(TpiPrime))).mmul(predScoreMat[i]), {
                computeLeftSingularVectors: true,
                computeRightSingularVectors: false
            });
            var CoTemp = result.leftSingularVectors;
            var SoTemp = result.diagonalMatrix;

            YOrthLoadingVec[i] = CoTemp.subMatrix(0, CoTemp.rows - 1, 0, 0);
            YOrthEigen[i] = SoTemp[0][0];

            YOrthScoreMat[i] = Matrix.Matrix.sub(kernelX[i][i], predScoreMat[i].mmul(TpiPrime)).mmul(predScoreMat[i]).mmul(YOrthLoadingVec[i]).mul(Math.pow(YOrthEigen[i], -0.5));

            var toiPrime = YOrthScoreMat[i].transpose();
            YOrthScoreNorm[i] = Matrix.Matrix.sqrt(toiPrime.mmul(YOrthScoreMat[i]));

            YOrthScoreMat[i] = YOrthScoreMat[i].divRowVector(YOrthScoreNorm[i]);

            var ITo = Matrix.Matrix.sub(Identity, YOrthScoreMat[i].mmul(YOrthScoreMat[i].transpose()));

            kernelX[0][i + 1] = kernelX[0][i].mmul(ITo);
            kernelX[i + 1][i + 1] = ITo.mmul(kernelX[i][i]).mmul(ITo);
        }

        var lastScoreMat = predScoreMat[this.orthogonalComp] = kernelX[0][this.orthogonalComp].transpose().mmul(YScoreMat).mmul(SigmaPow);

        var lastTpPrime = lastScoreMat.transpose();
        TURegressionCoeff[this.orthogonalComp] = Matrix.inverse(lastTpPrime.mmul(lastScoreMat)).mmul(lastTpPrime).mmul(YScoreMat);

        this.YLoadingMat = YLoadingMat;
        this.SigmaPow = SigmaPow;
        this.YScoreMat = YScoreMat;
        this.predScoreMat = predScoreMat;
        this.YOrthLoadingVec = YOrthLoadingVec;
        this.YOrthEigen = YOrthEigen;
        this.YOrthScoreMat = YOrthScoreMat;
        this.toNorm = YOrthScoreNorm;
        this.TURegressionCoeff = TURegressionCoeff;
        this.kernelX = kernelX;
    }

    /**
     * Predicts the output given the matrix to predict.
     * @param {Matrix|Array} toPredict
     * @return {{y: Matrix, predScoreMat: Array<Matrix>, predYOrthVectors: Array<Matrix>}} predictions
     */
    predict(toPredict) {

        var KTestTrain = this.kernel.compute(toPredict, this.trainingSet);

        var temp = KTestTrain;
        KTestTrain = new Matrix.Matrix(this.orthogonalComp + 1, this.orthogonalComp + 1);
        KTestTrain[0][0] = temp;

        var YOrthScoreVector = new Array(this.orthogonalComp);
        var predScoreMat = new Array(this.orthogonalComp);

        var i;
        for (i = 0; i < this.orthogonalComp; ++i) {
            predScoreMat[i] = KTestTrain[i][0].mmul(this.YScoreMat).mmul(this.SigmaPow);

            YOrthScoreVector[i] = Matrix.Matrix.sub(KTestTrain[i][i], predScoreMat[i].mmul(this.predScoreMat[i].transpose())).mmul(this.predScoreMat[i]).mmul(this.YOrthLoadingVec[i]).mul(Math.pow(this.YOrthEigen[i], -0.5));

            YOrthScoreVector[i] = YOrthScoreVector[i].divRowVector(this.toNorm[i]);

            var scoreMatPrime = this.YOrthScoreMat[i].transpose();
            KTestTrain[i + 1][0] = Matrix.Matrix.sub(KTestTrain[i][0], YOrthScoreVector[i].mmul(scoreMatPrime).mmul(this.kernelX[0][i].transpose()));

            var p1 = Matrix.Matrix.sub(KTestTrain[i][0], KTestTrain[i][i].mmul(this.YOrthScoreMat[i]).mmul(scoreMatPrime));
            var p2 = YOrthScoreVector[i].mmul(scoreMatPrime).mmul(this.kernelX[i][i]);
            var p3 = p2.mmul(this.YOrthScoreMat[i]).mmul(scoreMatPrime);

            KTestTrain[i + 1][i + 1] = p1.sub(p2).add(p3);
        }

        predScoreMat[i] = KTestTrain[i][0].mmul(this.YScoreMat).mmul(this.SigmaPow);
        var prediction = predScoreMat[i].mmul(this.TURegressionCoeff[i]).mmul(this.YLoadingMat.transpose());

        return {
            prediction: prediction,
            predScoreMat: predScoreMat,
            predYOrthVectors: YOrthScoreVector
        };
    }

    /**
     * Export the current model to JSON.
     * @return {object} - Current model.
     */
    toJSON() {
        return {
            name: 'K-OPLS',
            YLoadingMat: this.YLoadingMat,
            SigmaPow: this.SigmaPow,
            YScoreMat: this.YScoreMat,
            predScoreMat: this.predScoreMat,
            YOrthLoadingVec: this.YOrthLoadingVec,
            YOrthEigen: this.YOrthEigen,
            YOrthScoreMat: this.YOrthScoreMat,
            toNorm: this.toNorm,
            TURegressionCoeff: this.TURegressionCoeff,
            kernelX: this.kernelX,
            trainingSet: this.trainingSet,
            orthogonalComp: this.orthogonalComp,
            predictiveComp: this.predictiveComp
        };
    }

    /**
     * Load a K-OPLS with the given model.
     * @param {object} model
     * @param {Kernel} kernel - kernel used on the model, see [ml-kernel](https://github.com/mljs/kernel).
     * @return {KOPLS}
     */
    static load(model, kernel) {
        if (model.name !== 'K-OPLS') {
            throw new RangeError('Invalid model: ' + model.name);
        }

        if (!kernel) {
            throw new RangeError('You must provide a kernel for the model!');
        }

        model.kernel = kernel;
        return new KOPLS(true, model);
    }
}

exports.PLS = PLS;
exports.KOPLS = KOPLS;
